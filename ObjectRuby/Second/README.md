# 2周目の学習記録

## 第1章
### オブジェクト指向とは
- オブジェクト間のメッセージのやり取りに着目して設計を行う。
- 依存関係を管理すること

### 目指すべきものは（良い設計とは）
状況の変化は必ず起こる。ソースコードも同様に必ず変化するものである。  
だからこそ <span style=color:red>**未来に選択肢を残す**</span>事のできる良い設計を目指す必要がある

### アンチパターン
1. オブジェクトが知識を持ちすぎる状況は良くない。

    ``` plantuml
    @startuml
    class Y

    Y --> A
    Y --> B
    Y --> C

    note right of Y
    YはY自身の変更だけでなく、
    A,B,Cの変更によっても変化する可能性がある。
    Clean Architectureでは安定度・移植性が低いクラスとして言われている。
    endnote
    @enduml
    ```

2. 過度な設計   
設計の手法を学ぶと先行して設計を進めてしまう状態になる。  
(自分がまさに現状この状態に感じている)  
そのような過剰な設計は**良い設計**にはならない。
指標として、  
```
設計にかかる期間と
効果が出るまでの期間の比較で
設計の良し悪しを判断することもできる。
```
設計に時間がかかっても現状不要なら後回しでも問題ない。(必要にならないから)  
(YANGNIの考え方)
設計に時間がかかって今すぐに効果が出ないなら後で設計すればいい。  
そのときには情報も増えているのでより良い設計ができるはずだ。


### 手続き型言語とオブジェクト指向言語の違い
新しいデータ型とできること(メソッド)をまとめて管理ができる。

``` plantuml
@startmindmap
* オブジェクト指向
** 文字列オブジェクトをRubyは知らない
** Classクラスについては知っている
*** 定義されたメッセージを送れること
** 新しいクラスはClassクラスのインスタンスである

* 手続き型言語
** 文字列型をC言語は知っている。
** 文字列型を操作する方法をC言語は知っている。
*** ライブラリとして提供する
** ユーザ独自のデータ型を追加できない。
@endmindmap
```

## 第2章
### 単一責任の原則
- 一つのアクターに対して責任を持つ
- 一つの目的に対して責任を持つ
- 一つのアクター、目的への責任を果たすために複数の責任（メッセージ）を持つ

#### 単一責任の設計の考え方
- データとメソッドをグループにまとめる。
- 設計の妥当性を確認する方法
    1. クラスに質問する。
        - ◎: Gearさんあなたのギア比を教えて下さい。
        - △: Gearさんあなたのギアインチを教えて下さい。(このタイヤとのギアインチを教えて下さいは有り)
        - ×: Gearさんあなたのタイヤサイズを教えて下さい。(タイヤに聞いてくだい・・・)
        - △: Gearさんあなたの持っているタイヤを教えて下さい。(has-aの関係で設計してればOK)
    2. 一文で説明する（誰に何の責任があるのか？）
        - Gearさんは自転車へのギアの影響を計算する

#### リファクタリング
最初から完璧な設計はできないし、将来どんな変更があるかもわからない。  
まずは、メソッドを単一責任にしてみる。  
クラスのリファクタリングが必要なときに簡単に実行できるようにしておく。
##### メリット
- 構造を大きく変えなくてもリファクタリングが安全にできる
- メソッドの役割が明確になる
- メソッドの再利用性が上がる
- クラスの役割が明確になる
- クラスのリファクタリングがしやすくなる。
    - 単一責任のメソッドを再利用性が高いので別のクラスに移行できる
- クラスの再利用性が上がる。

### 変更に強い(単一責任な)良い設計の指標
#### かんたんに変更ができることとは
- 副作用を持たない
- 少ない変更で対応できる(変化に対して過剰な変更が必要ない)
- 再利用できる
- 追加で変更を加える手段がある(オープン・クローズドの原則)
####  良い設計(変更に強いコード)とは
- Transparent: 見通しが良い -> 影響範囲が追える。明白である。
- Reasonable: 合理的 -> 必要な変更のコストとその利益が釣り合っている
- Usable: 利用性が高い -> 再利用できる
- Exemplary: 模範的 -> コードの変更も良い設計に向かうようになる

#### アンチパターンと対策
- データ構造へ依存している
    - 理由:
        - 複雑なデータに依存するとそのデータを扱う処理すべてがデータ構造の変更の影響を受ける。
    - 対策:
        - データではなく振る舞い(メッセージ)に依存する。
            - クラス内でもPropertyなどに依存することでデータ変更の影響をPropertyの実装に限定できる。
        - データを扱う複雑な処理が集約される

