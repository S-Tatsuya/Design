# 2周目の学習記録

## 第1章
### オブジェクト指向とは
- オブジェクト間のメッセージのやり取りに着目して設計を行う。
- 依存関係を管理すること

### 目指すべきものは（良い設計とは）
状況の変化は必ず起こる。ソースコードも同様に必ず変化するものである。  
だからこそ <span style=color:red>**未来に選択肢を残す**</span>事のできる良い設計を目指す必要がある

### アンチパターン
1. オブジェクトが知識を持ちすぎる状況は良くない。

    ``` plantuml
    @startuml
    class Y

    Y --> A
    Y --> B
    Y --> C

    note right of Y
    YはY自身の変更だけでなく、
    A,B,Cの変更によっても変化する可能性がある。
    Clean Architectureでは安定度・移植性が低いクラスとして言われている。
    endnote
    @enduml
    ```

2. 過度な設計   
設計の手法を学ぶと先行して設計を進めてしまう状態になる。  
(自分がまさに現状この状態に感じている)  
そのような過剰な設計は**良い設計**にはならない。
指標として、  
```
設計にかかる期間と
効果が出るまでの期間の比較で
設計の良し悪しを判断することもできる。
```
設計に時間がかかっても現状不要なら後回しでも問題ない。(必要にならないから)  
(YANGNIの考え方)
設計に時間がかかって今すぐに効果が出ないなら後で設計すればいい。  
そのときには情報も増えているのでより良い設計ができるはずだ。


### 手続き型言語とオブジェクト指向言語の違い
新しいデータ型とできること(メソッド)をまとめて管理ができる。

``` plantuml
@startmindmap
* オブジェクト指向
** 文字列オブジェクトをRubyは知らない
** Classクラスについては知っている
*** 定義されたメッセージを送れること
** 新しいクラスはClassクラスのインスタンスである

* 手続き型言語
** 文字列型をC言語は知っている。
** 文字列型を操作する方法をC言語は知っている。
*** ライブラリとして提供する
** ユーザ独自のデータ型を追加できない。
@endmindmap
```

## 第2章
### 単一責任の原則
- 一つのアクターに対して責任を持つ
- 一つの目的に対して責任を持つ
- 一つのアクター、目的への責任を果たすために複数の責任（メッセージ）を持つ

#### 単一責任の設計の考え方
- データとメソッドをグループにまとめる。
- 設計の妥当性を確認する方法
    1. クラスに質問する。
        - ◎: Gearさんあなたのギア比を教えて下さい。
        - △: Gearさんあなたのギアインチを教えて下さい。(このタイヤとのギアインチを教えて下さいは有り)
        - ×: Gearさんあなたのタイヤサイズを教えて下さい。(タイヤに聞いてくだい・・・)
        - △: Gearさんあなたの持っているタイヤを教えて下さい。(has-aの関係で設計してればOK)
    2. 一文で説明する（誰に何の責任があるのか？）
        - Gearさんは自転車へのギアの影響を計算する

#### リファクタリング
最初から完璧な設計はできないし、将来どんな変更があるかもわからない。  
まずは、メソッドを単一責任にしてみる。  
クラスのリファクタリングが必要なときに簡単に実行できるようにしておく。
##### メリット
- 構造を大きく変えなくてもリファクタリングが安全にできる
- メソッドの役割が明確になる
- メソッドの再利用性が上がる
- クラスの役割が明確になる
- クラスのリファクタリングがしやすくなる。
    - 単一責任のメソッドを再利用性が高いので別のクラスに移行できる
- クラスの再利用性が上がる。

### 変更に強い(単一責任な)良い設計の指標
#### かんたんに変更ができることとは
- 副作用を持たない
- 少ない変更で対応できる(変化に対して過剰な変更が必要ない)
- 再利用できる
- 追加で変更を加える手段がある(オープン・クローズドの原則)
####  良い設計(変更に強いコード)とは
- Transparent: 見通しが良い -> 影響範囲が追える。明白である。
- Reasonable: 合理的 -> 必要な変更のコストとその利益が釣り合っている
- Usable: 利用性が高い -> 再利用できる
- Exemplary: 模範的 -> コードの変更も良い設計に向かうようになる

#### アンチパターンと対策
- データ構造へ依存している
    - 理由:
        - 複雑なデータに依存するとそのデータを扱う処理すべてがデータ構造の変更の影響を受ける。
    - 対策:
        - データではなく振る舞い(メッセージ)に依存する。
            - クラス内でもPropertyなどに依存することでデータ変更の影響をPropertyの実装に限定できる。
        - データを扱う複雑な処理が集約される

## 第3章
### 依存の管理
- 依存性の注入によりオブジェクトの再利用性は上がる。
- 依存する場合は、依存する箇所を最小限にするようにラップメソッドを用意する
- 依存の方向を管理する。変更されやすく、依存が多いオブジェクトは危険

### 依存とは
依存とは知識である。  
オブジェクトは責任を果たすために必要な最低限の知識のみ知るようにしないといけない。（デメテルの法則）  
```
例.
オブジェクトはメッセージを使うために他のクラスの名前を知る必要はない
```
プログラムでの知識とは以下のことである。
- オブジェクトが知っていること
- オブジェクトのオブジェクトが知っていること
- 他のオブジェクトが知っていること

何を知っていると依存なのか？
- 他のクラスの名前
- 外部メッセージの名前
- 外部メッセージの引数
- 外部メッセージの引数の順番

### 依存と対策
|依存|対策|理由|
|---|---|---|
|他のクラスの名前|依存性の注入|インターフェースなどメッセージに依存するべき|
|↑|依存の隔離|クラスの生成を隔離して依存箇所を一箇所にする（ラップする）|
|メッセージの名前|脆い外部メッセージを隔離|メッセージの呼び出しは一箇所にする（ラップする）|
|メッセージの引数|可変長引数を使う|引数が変更になっても影響が少ない|
|↑|デフォルト値の設定|引数を変えてもデフォルト値があるので従来のコードは変更不要|
|引数の順番|可変長引数を使う|引数が変更になっても影響が少ない|

### 依存の方向
自分より変更されないものに依存する。  
自分は一つのオブジェクトにしか依存していなくてもそのオブジェクトが10個に依存していたらダメ。
- 安定度の高いオブジェクトの特徴
    - 要件の変更頻度はどうか？
    - 依存の数が多い。良くも悪くも変更コストが高いので現実的に安定しやすい
    - 抽象度が高い

以下のDに依存するのは最悪だし、そもそもDが存在するのが最悪
```
依存
高
│    A   D
│
│    B   C
低/少──────多
```

### アンチパターン
気づきにくいパターン
- 間接的なクラスへの依存
    - `A -> B -> C`の依存関係があるときにAがBに依存しているのがCを使うためなど
- テストとプロダクトコードの依存
    - プロダクトコードに依存したテストコードはメンテナスが難しくテストコードが捨てられる危険性がある。

## 第4章
### インターフェースの役割
インターフェースには2種類ある。
- パブリックインターフェース: クラスの主要な責任(単一責任の原則の目的)を明らかにする。安定したメソッドである。
- プライベートインターフェース: クラスの詳細な実装。不安定なメソッドである

### オブジェクト指向とは
```
クラスにより成り立ち、メッセージで定義される
```
メッセージを決めて `誰に` 送るかを考える。  
`誰が` を決めて `何を送るか` を考えるのではない。  
メッセージを送るために `クラス` が存在する。  
メッセージから検討することで見えにくい `オブジェクト` に気づきやすくなる。

外部フレームワークに依存することは危険である。  
-> Clean Architectureでも同様の指摘があった。


### シーケンス図を書く
オブジェクト指向の最重要な図は `クラス図` ではなく `シーケンス図` である。  
( `クラス図` も重要な図である)

#### シーケンス図を書くときの質問
1. メッセージの受け手は、そのメッセージに応える責任を負うべきか？
2. 送り手は「何を」頼んでいるか？ -> 相手をどのように信じているか？
    - 判断のロジックは `料理` をしていることになる。基本的には `注文`する意識でメッセージを使う。
3. 送り手は「どのように」を知って**いない**か？
4. 送り手は相手が「誰か」を知っているか？ -> クラスの名前を知っているか？
    - オブジェクトがクラス名に依存するのは避けるべき([参考：依存と対策](#依存と対策)
5. オブジェクトはどのコンテキスト(処理の流れ)に存在しているか？ -> どれだけの要素に依存しているか？

#### デメテルの法則
オブジェクトが直接依存していないオブジェクトを使うために他のオブジェクトを経由していないか？  
`.` によるチェーンが最小(1つ)になっているか？  
デメテルの法則に違反した場合は、ラッパーメソッドを使うなど対策が必要。  
(ラッパーメソッドは依存を隠すだけで本質の改善にはならない場合もある。)  
「何を」に着目してメッセージの設計をやり直すのも大切。

### インターフェース(メッセージ)の要件
- 明示的にパブリックだと特定出来る。-> Privateの場合はメソッド名の先頭に `_` を入れる。
- 「何を」になっている。 -> 相手が「どの順番でメソッドを使うか」などを意識しないで良くなっている。
- 名前をあまり変えない。 -> 変更の影響を相手に与えてしまう。
- オプション引数はハッシュを使う(デフォルト値でもギリギリOK！！)

### 不明点
旅行の例で、 `Trip`クラスが `自転車`を準備する必要があることを知るべきではない。  
-> 自分を準備してくれるオブジェクト(メッセージ)をする知るべき。
-> この部分が `Trip` クラスが自分を準備するために必要なことを知っていてもいいのではないかと感じた。

## 第5章
### ダックタイプを活用しよう!!
オブジェクトが  
`何か(クラス名)` に着目するのではなく  
`何をするか(メッセージ)` に着目して設計、実装を行うべきである。  
ダックタイプは `オブジェクト` をより `抽象的な要素(仮想の型)` として扱うことで  
拡張性の高い実装を可能にする。

`何をするか(メッセージ)` は、`インターフェース` や `抽象クラス` を設計するときの  
クライアントオブジェクトからサービスオブジェクトへの要求の考え方と同じ。  
`誰に頼みたいか?` ではなく `何を頼みたいか？` を考えて設計する。

### ダックタイプの使い方
1. 分岐からダックタイプを見つける。  
    - クラスの判別をしている箇所があれば `Strategyパターン` の合図。
    - `Strategyパターン` を `インターフェース` の実装なしで実現できるのが `ダックタイプ`!!
    -  メッセージの引数は、単一の目的を達成するために受け取る。  
    `引数を使って何をしたいのか？` を考えるとダックタイプを見つけることが出来るかもしれない。
2. テスト(文書)を用意する。
    - 静的型付け言語に比べれば壊れやすいので、テストは必須。
    - また、他の人(将来の自分)に意図を伝えるための文書としてもテストは残すべき!!
3. 本当に必要かを考える。
    - ダックタイプも万能ではないので不要な場合は使わなくてもOK
        - 言語仕様など自身より安定度の高いコードへの依存は無理に取り去る必要はない。
        - `拡張性 <->  理解しやすさ` はトレードオフの関係である

### 用語
- メタプログラミング: 実行中にプログラムを生成したり、記述する手法。とても便利だが難しいらしい。
- シグネチャ: メソッドの `名前` + `引数` + `戻り値` のこと。

### 動的型付け言語の強み
- メタプログラミングが使いこなせれば強力
- 静的型付け言語のメリット(コンパイルの型チェック、可視化された型情報)は、テストで補える。

ただし、 `実行速度` だけは静的型付け言語には勝てない。

