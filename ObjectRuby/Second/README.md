# 2周目の学習記録

## 第1章
### オブジェクト指向とは
- オブジェクト間のメッセージのやり取りに着目して設計を行う。
- 依存関係を管理すること

### 目指すべきものは（良い設計とは）
状況の変化は必ず起こる。ソースコードも同様に必ず変化するものである。  
だからこそ <span style=color:red>**未来に選択肢を残す**</span>事のできる良い設計を目指す必要がある

### アンチパターン
1. オブジェクトが知識を持ちすぎる状況は良くない。

    ``` plantuml
    @startuml
    class Y

    Y --> A
    Y --> B
    Y --> C

    note right of Y
    YはY自身の変更だけでなく、
    A,B,Cの変更によっても変化する可能性がある。
    Clean Architectureでは安定度・移植性が低いクラスとして言われている。
    endnote
    @enduml
    ```

2. 過度な設計   
設計の手法を学ぶと先行して設計を進めてしまう状態になる。  
(自分がまさに現状この状態に感じている)  
そのような過剰な設計は**良い設計**にはならない。
指標として、  
```
設計にかかる期間と
効果が出るまでの期間の比較で
設計の良し悪しを判断することもできる。
```
設計に時間がかかっても現状不要なら後回しでも問題ない。(必要にならないから)  
(YANGNIの考え方)
設計に時間がかかって今すぐに効果が出ないなら後で設計すればいい。  
そのときには情報も増えているのでより良い設計ができるはずだ。


### 手続き型言語とオブジェクト指向言語の違い
新しいデータ型とできること(メソッド)をまとめて管理ができる。

``` plantuml
@startmindmap
* オブジェクト指向
** 文字列オブジェクトをRubyは知らない
** Classクラスについては知っている
*** 定義されたメッセージを送れること
** 新しいクラスはClassクラスのインスタンスである

* 手続き型言語
** 文字列型をC言語は知っている。
** 文字列型を操作する方法をC言語は知っている。
*** ライブラリとして提供する
** ユーザ独自のデータ型を追加できない。
@endmindmap
```

## 第2章
### 単一責任の原則
- 一つのアクターに対して責任を持つ
- 一つの目的に対して責任を持つ
- 一つのアクター、目的への責任を果たすために複数の責任（メッセージ）を持つ

#### 単一責任の設計の考え方
- データとメソッドをグループにまとめる。
- 設計の妥当性を確認する方法
    1. クラスに質問する。
        - ◎: Gearさんあなたのギア比を教えて下さい。
        - △: Gearさんあなたのギアインチを教えて下さい。(このタイヤとのギアインチを教えて下さいは有り)
        - ×: Gearさんあなたのタイヤサイズを教えて下さい。(タイヤに聞いてくだい・・・)
        - △: Gearさんあなたの持っているタイヤを教えて下さい。(has-aの関係で設計してればOK)
    2. 一文で説明する（誰に何の責任があるのか？）
        - Gearさんは自転車へのギアの影響を計算する

#### リファクタリング
最初から完璧な設計はできないし、将来どんな変更があるかもわからない。  
まずは、メソッドを単一責任にしてみる。  
クラスのリファクタリングが必要なときに簡単に実行できるようにしておく。
##### メリット
- 構造を大きく変えなくてもリファクタリングが安全にできる
- メソッドの役割が明確になる
- メソッドの再利用性が上がる
- クラスの役割が明確になる
- クラスのリファクタリングがしやすくなる。
    - 単一責任のメソッドを再利用性が高いので別のクラスに移行できる
- クラスの再利用性が上がる。

### 変更に強い(単一責任な)良い設計の指標
#### かんたんに変更ができることとは
- 副作用を持たない
- 少ない変更で対応できる(変化に対して過剰な変更が必要ない)
- 再利用できる
- 追加で変更を加える手段がある(オープン・クローズドの原則)
####  良い設計(変更に強いコード)とは
- Transparent: 見通しが良い -> 影響範囲が追える。明白である。
- Reasonable: 合理的 -> 必要な変更のコストとその利益が釣り合っている
- Usable: 利用性が高い -> 再利用できる
- Exemplary: 模範的 -> コードの変更も良い設計に向かうようになる

#### アンチパターンと対策
- データ構造へ依存している
    - 理由:
        - 複雑なデータに依存するとそのデータを扱う処理すべてがデータ構造の変更の影響を受ける。
    - 対策:
        - データではなく振る舞い(メッセージ)に依存する。
            - クラス内でもPropertyなどに依存することでデータ変更の影響をPropertyの実装に限定できる。
        - データを扱う複雑な処理が集約される

## 第3章
### 依存の管理
- 依存性の注入によりオブジェクトの再利用性は上がる。
- 依存する場合は、依存する箇所を最小限にするようにラップメソッドを用意する
- 依存の方向を管理する。変更されやすく、依存が多いオブジェクトは危険

### 依存とは
依存とは知識である。  
オブジェクトは責任を果たすために必要な最低限の知識のみ知るようにしないといけない。（デメテルの法則）  
```
例.
オブジェクトはメッセージを使うために他のクラスの名前を知る必要はない
```
プログラムでの知識とは以下のことである。
- オブジェクトが知っていること
- オブジェクトのオブジェクトが知っていること
- 他のオブジェクトが知っていること

何を知っていると依存なのか？
- 他のクラスの名前
- 外部メッセージの名前
- 外部メッセージの引数
- 外部メッセージの引数の順番

### 依存と対策
|依存|対策|理由|
|---|---|---|
|他のクラスの名前|依存性の注入|インターフェースなどメッセージに依存するべき|
|↑|依存の隔離|クラスの生成を隔離して依存箇所を一箇所にする（ラップする）|
|メッセージの名前|脆い外部メッセージを隔離|メッセージの呼び出しは一箇所にする（ラップする）|
|メッセージの引数|可変長引数を使う|引数が変更になっても影響が少ない|
|↑|デフォルト値の設定|引数を変えてもデフォルト値があるので従来のコードは変更不要|
|引数の順番|可変長引数を使う|引数が変更になっても影響が少ない|

### 依存の方向
自分より変更されないものに依存する。  
自分は一つのオブジェクトにしか依存していなくてもそのオブジェクトが10個に依存していたらダメ。
- 安定度の高いオブジェクトの特徴
    - 要件の変更頻度はどうか？
    - 依存の数が多い。良くも悪くも変更コストが高いので現実的に安定しやすい
    - 抽象度が高い

以下のDに依存するのは最悪だし、そもそもDが存在するのが最悪
```
依存
高
│    A   D
│
│    B   C
低/少──────多
```

### アンチパターン
気づきにくいパターン
- 間接的なクラスへの依存
    - `A -> B -> C`の依存関係があるときにAがBに依存しているのがCを使うためなど
- テストとプロダクトコードの依存
    - プロダクトコードに依存したテストコードはメンテナスが難しくテストコードが捨てられる危険性がある。

## 第4章
### インターフェースの役割
インターフェースには2種類ある。
- パブリックインターフェース: クラスの主要な責任(単一責任の原則の目的)を明らかにする。安定したメソッドである。
- プライベートインターフェース: クラスの詳細な実装。不安定なメソッドである

### オブジェクト指向とは
```
クラスにより成り立ち、メッセージで定義される
```
メッセージを決めて `誰に` 送るかを考える。  
`誰が` を決めて `何を送るか` を考えるのではない。  
メッセージを送るために `クラス` が存在する。  
メッセージから検討することで見えにくい `オブジェクト` に気づきやすくなる。

外部フレームワークに依存することは危険である。  
-> Clean Architectureでも同様の指摘があった。


### シーケンス図を書く
オブジェクト指向の最重要な図は `クラス図` ではなく `シーケンス図` である。  
( `クラス図` も重要な図である)

#### シーケンス図を書くときの質問
1. メッセージの受け手は、そのメッセージに応える責任を負うべきか？
2. 送り手は「何を」頼んでいるか？ -> 相手をどのように信じているか？
    - 判断のロジックは `料理` をしていることになる。基本的には `注文`する意識でメッセージを使う。
3. 送り手は「どのように」を知って**いない**か？
4. 送り手は相手が「誰か」を知っているか？ -> クラスの名前を知っているか？
    - オブジェクトがクラス名に依存するのは避けるべき([参考：依存と対策](#依存と対策)
5. オブジェクトはどのコンテキスト(処理の流れ)に存在しているか？ -> どれだけの要素に依存しているか？

#### デメテルの法則
オブジェクトが直接依存していないオブジェクトを使うために他のオブジェクトを経由していないか？  
`.` によるチェーンが最小(1つ)になっているか？  
デメテルの法則に違反した場合は、ラッパーメソッドを使うなど対策が必要。  
(ラッパーメソッドは依存を隠すだけで本質の改善にはならない場合もある。)  
「何を」に着目してメッセージの設計をやり直すのも大切。

### インターフェース(メッセージ)の要件
- 明示的にパブリックだと特定出来る。-> Privateの場合はメソッド名の先頭に `_` を入れる。
- 「何を」になっている。 -> 相手が「どの順番でメソッドを使うか」などを意識しないで良くなっている。
- 名前をあまり変えない。 -> 変更の影響を相手に与えてしまう。
- オプション引数はハッシュを使う(デフォルト値でもギリギリOK！！)

### 不明点
旅行の例で、 `Trip`クラスが `自転車`を準備する必要があることを知るべきではない。  
-> 自分を準備してくれるオブジェクト(メッセージ)をする知るべき。
-> この部分が `Trip` クラスが自分を準備するために必要なことを知っていてもいいのではないかと感じた。

## 第5章
### ダックタイプを活用しよう!!
オブジェクトが  
`何か(クラス名)` に着目するのではなく  
`何をするか(メッセージ)` に着目して設計、実装を行うべきである。  
ダックタイプは `オブジェクト` をより `抽象的な要素(仮想の型)` として扱うことで  
拡張性の高い実装を可能にする。

`何をするか(メッセージ)` は、`インターフェース` や `抽象クラス` を設計するときの  
クライアントオブジェクトからサービスオブジェクトへの要求の考え方と同じ。  
`誰に頼みたいか?` ではなく `何を頼みたいか？` を考えて設計する。

### ダックタイプの使い方
1. 分岐からダックタイプを見つける。  
    - クラスの判別をしている箇所があれば `Strategyパターン` の合図。
    - `Strategyパターン` を `インターフェース` の実装なしで実現できるのが `ダックタイプ`!!
    -  メッセージの引数は、単一の目的を達成するために受け取る。  
    `引数を使って何をしたいのか？` を考えるとダックタイプを見つけることが出来るかもしれない。
2. テスト(文書)を用意する。
    - 静的型付け言語に比べれば壊れやすいので、テストは必須。
    - また、他の人(将来の自分)に意図を伝えるための文書としてもテストは残すべき!!
3. 本当に必要かを考える。
    - ダックタイプも万能ではないので不要な場合は使わなくてもOK
        - 言語仕様など自身より安定度の高いコードへの依存は無理に取り去る必要はない。
        - `拡張性 <->  理解しやすさ` はトレードオフの関係である

### 用語
- メタプログラミング: 実行中にプログラムを生成したり、記述する手法。とても便利だが難しいらしい。
- シグネチャ: メソッドの `名前` + `引数` + `戻り値` のこと。

### 動的型付け言語の強み
- メタプログラミングが使いこなせれば強力
- 静的型付け言語のメリット(コンパイルの型チェック、可視化された型情報)は、テストで補える。

ただし、 `実行速度` だけは静的型付け言語には勝てない。

## 6章
### 継承
継承はメッセージの**自動委譲**の機能である。  
サブクラスが知らないメッセージを受け取った場合に親クラスに**委譲**する。  
基本的な考え方はコードの明示的な委譲と同じである。

### 継承の種類
1. クラス: クラスの継承の機能
2. プロタイプ: Lua、Javascriptなどのクラスの作り方。テーブル、メタテーブルを使う方法
3. モジュール: mix-inなどの方法

### 継承の使い所に気づくには
基本的にはダックタイプと同じである。  
メッセージを送る時に相手(誰)を気にしているコードは `継承` を使うべきかもしれない

### 継承を使うときのルール
1. 一般(親) - 特殊(子)の関係になる場合に使う
2. 正しいコーディングテクニックを使う
    - 具象クラスを継承しない。
        - 具象クラスは変化が起きやすいので依存するべきではない
        - 具象クラス = 特殊な処理も持つので適切に抽象化されているクラスは継承してはいけない。
    - 抽象クラスを抽出する場合は `3つの具象クラス` が見つかってから行うのが良い。
        - 2つの具象クラスでは抽象化を間違う危険性があるため
        - できるだけ多くの情報を待つほうが良い。ただし、待つことで変更コストが高まるならやって良い。  
        丁度いいのが `3つの具象クラス` に気づいたとき
3. superへの依存も避ける。誰を意識していることに変わりはない。
    - サブクラウは特化した領域にのみ責任を持つべきである。
    - `Template Methodパターン(フックメソッド)` を使いこなす。
        - 一般的なアルゴリズムは親が持ち、特化した処理だけ子が持つ。

### その他
- リファクタリングのコツは、間違えた時に最小の被害、気づきやすいエラーになるようにする
    - 具象 -> 抽象に引き上げるようにする。

- 継承の矢印の向きはメッセージの委譲の方向になっている。
``` plantuml
@startuml
class 親{}
親 <|-- 子
note right on link
委譲の向きを表している
依存の向きでもある
end note
@enduml
```

- 再利用性の高い(小さな自己完結型)オブジェクトの特徴
    - 最小限のコンテキスト
    - 明快なインターフェース
    - 依存性の注入がされている

## 第7章
### ロール
ダックタイプは、インターフェースの共有である。  
ロールは、インターフェースだけでなく、**振る舞い**も共有する。  
Pythonでは、 `抽象クラス` と `Mixin` の考え方を使う。  
Rubyでは、 `モジュール` を使う。

### ロールを見つける
Aを**する**オブジェクトがあれば、 Aをされる**オブジェクト**もある。
- 例.
``` 
Preparerロール(準備するロール)があれば、
Preparableロール(準備されるロール)もある。
```
Aを**する**オブジェクトは、それごとに処理が異なることが多い。  
-> ダックタイプ、インターフェース、抽象クラス  
Aを**される**オブジェクトは、同じ処理になることもある。
-> モジュール、抽象クラス


### 設計の考え方
- オブジェクトは自身を管理すべきである。  
    - オブジェクトの状態はオブジェクトに聞くべきであり、他のオブジェクトが答えることではない。
    - コンテキストを最小化する効果もある

### 継承可能なコードを書く
- アンチパターン
    - type()メソッドを使っている
        - 自分(親)が誰かを気にしている
            - 抽象クラスを使う
        - 相手が誰かを気にしている
            - インターフェース(ダックタイプ)を使う -> ロール間でのメッセージの共有
            - 抽象クラス(モジュール)を使う -> ロール間での振る舞いの共有
- スーパークラスの要素は全てのサブクラスで使う
    - リスコフの置換原則: サブクラスは全てスーパークラスと交換可能である
    - スーパークラスの要素は全てサブクラスで使う(インターフェース分離の原則)。
        - 抽象化の対象を間違えている可能性がある。(has-aの関係を使ったり、インターフェースを分離するべき)
- テンプレートメソッドパターンを使う
    - スーパークラスが**一般化された処理**を行い(テンプレートメソッドの処理)
    - サブクラスが**特化された処理**を行う(フックメソッドの処理)

## 第8章
### コンポジション
部品の集合委譲の価値を提供する組わせを作ること。  
`全体 - 部品`間のメッセージの設計。  
シンプルなパーツを組み合わせて複雑な様々な振る舞いを実装する場合に有効。

- **is-a**: 抽象クラス -> `一般 - 特化`の関係。大部分が共通で**一部**の振る舞いだけ変える
- **ロール**: インターフェース(Mixin) -> クライアントが求める**契約(メッセージ)**を守ることで振る舞いを変えられる。
- **has-a**: コンポジション -> シンプルは部品を組み合わせてより**複雑な処理**を行えるオブジェクトを作る。

### コンポジションのメリット、デメリット
- メリット
    1. 継承より各クラスの役割が明確になり、分割がしやすい -> 単一責任。利用性+見通しが良い。
    2. クラスを作る必要がなくなる。
        - 継承の場合に新しいクラスが必要になる場合もコンポジションでは組み合わせの定義だけで作ることが出来る。
        - 組み合わせの定義もFactoryクラスでカプセル化することが出来る。
    3. インターフェースを守れば拡張可能。 -> O/Cの原則。合理性。
- デメリット
    1. 個別のクラスの見通しは良いが組み合わせが複雑になると全体の見通しが難しくなる。
    2. 継承と比べて処理の共有が難しくなる。

#### VS 継承

||独立性|委譲|見通し|合理性|利用性|模範的|
|----|----|----|----|----|----|----|
|コンポジション|高い|手動(プログラマが明示的に行う)|良い|良い|良い|まあまま(指針にはならない)|
|継承|低い(階層構造に依存)|自動|悪い(親クラスにも処理が書かれている)|良い|良い|良い|

- 継承のリスク
    - 誤用するとデメリットのみになる -> 使い所が難しい
    - 壊れやすい。親クラスの変更が子クラスに影響するため、少ないコードで変更出来るが、意図しない振る舞いも広がりやすい。
    - 汎用性の高いコードには使えない。-> クラスの階層構造をコンテキストに持っている。多重継承は危険なため、継承できない場合もある。


## 第9章
### テスト
- テストすべきこと
    1. 受信メッセージをテストする
    2. 送信メッセージのコマンドは送る責任を果たしていることをテストする
    3. ダックタイプをテストする(ロールに対するテストを行う)
    4. 継承のテスト
- テストすべきでないこと
    1. 送信メッセージのクエリはテストしない
        - 受信側でクエリの振る舞いはテストする。送信側はスタブでOK
    2. プライベートメソッドはテストしない。
        - パブリックメソッドのテストで内包されるはず

### 変更可能なコードを書くには
1. オブジェクト指向の知識(疎結合なコードを書く技術)
2. リファクタリングの知識(壊さない修正をする技術)
3. 価値の高いテスト(壊れていないことを証明する)

### テストする目的
**最大の目的**は、コストの削減である。  
その他の目的は以下の通りである。
- バグの発見
- 仕様書になる
- 設計の決定を遅らせる
    - インターフェースに依存する(Mock、スタブを使う)ことで、抽象を支えることが出来る
- 設計の欠陥を明らかにする
    - テストに求められるコンテキストで結合度合いを測ることが出来る
- 何をテストするのか明確にする
    - テストの重複も禁止。確認は1ヵ所だけにする

### テストのポイント
1. 共通
    - 意図の明確さを意識する(何を、いつ、どのようにテストするのか)
    - オブジェクトのメッセージにのみ着目してテストを書く
    - テスト対象のオブジェクトのみを見てテストを書く
        - 他のオブジェクトの知識を使わずにテストできない = 密結合のオブジェクトがある
    - テスト対象の外からの視点でテストを書く
        - ユニットテストであっても出入りするメッセージに着目する
        - カバレッジは別の話
    - プロダクトコードでは使わないメソッドは削除する
        - メンテナンスコストを上げるだけで意味がない
    - 抽象クラス(ロール)を注入する
        - 依存性の注入を活用してテストをシンプルにする
    - テストダブルをうまく使う
    - ロールを明確にするテストを書く
        - テストの名前にロール名を書いてしまうなど
    - ロールに対するテストは共有出来る手段を用意する
    - ロールをMock化する場合に不具合に気づけない可能性があるので注意する。
        - 基本的には面倒くさくても抽象クラスを定義するべきな気がする・・・

### 心に残った言葉
- 新しい手法を取り入れて著しく生産性が下がった場合には手法のせいではなく使いこなせていないスキルに着目する。
    - どんな素晴らしい手法も慣れやリズムを掴むまではコストが上がる。
- BDDは外から内にテストする
- TDDは内から外にテストする
    - オブジェクトの再利用も大切。ただし、テストが壊れる危険があることも認識してMockも活用する。
- テストダブルは総称
    - スタブ
    - モック
    - フェイク 
    - スパイ

